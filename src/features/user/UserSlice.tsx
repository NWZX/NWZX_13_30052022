import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { useEffect, useState } from 'react';
import { useAppDispatch, useAppSelector } from 'app/hooks';
import { fetchToken, fetchUser, updateUser } from 'data/servicesAPIProvider';
import { IUser } from 'interfaces/IUser';

export interface UserState {
    user: IUser | undefined;
    token: string | undefined;
    status: 'auth' | 'loading' | 'guest' | 'error';
}

const initialToken =
    window.localStorage.getItem('app_token') || window.sessionStorage.getItem('app_token') || undefined;
const initialState: UserState = {
    user: undefined,
    token: initialToken || undefined,
    status: initialToken ? 'auth' : 'guest',
};

type TAuthLogin = { email: string; password: string; remember?: boolean };
export const LoginAsync = createAsyncThunk('user/login', async ({ email, password, remember }: TAuthLogin) => {
    const response = await fetchToken(email, password);
    if (response?.token) {
        return { ...response, remember };
    }
    throw new Error('Invalid email or password');
});
export const GetUserAsync = createAsyncThunk('user/get', async ({ token }: { token?: string }) => {
    const response = await fetchUser(token);
    // The value we return becomes the `fulfilled` action payload
    return response;
});
export const UpdateUserAsync = createAsyncThunk(
    'user/update',
    async ({ token, user }: { token?: string; user?: Partial<IUser> }) => {
        const response = await updateUser(token, user);
        // The value we return becomes the `fulfilled` action payload
        return response;
    },
);

export const userSlice = createSlice({
    name: 'user',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        logout: (state) => {
            state.user = undefined;
            state.status = 'guest';
            window.localStorage.removeItem('app_token');
            window.sessionStorage.removeItem('app_token');
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(LoginAsync.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(LoginAsync.fulfilled, (state, action) => {
                state.status = 'auth';
                state.token = action.payload.token;
                if (action.payload.remember) {
                    window.localStorage.setItem('app_token', action.payload.token);
                } else {
                    window.sessionStorage.setItem('app_token', action.payload.token);
                }
            })
            .addCase(LoginAsync.rejected, (state) => {
                state.status = 'error';
            })
            //Get
            .addCase(GetUserAsync.fulfilled, (state, action) => {
                state.user = action.payload;
            })
            //Update
            .addCase(UpdateUserAsync.fulfilled, (state, action) => {
                state.user = action.payload;
            });
    },
});

export const { logout } = userSlice.actions;

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export const useProfile = () => {
    const User = useAppSelector((state) => state.user.user);
    const Token = useAppSelector((state) => state.user.token);
    const dispatch = useAppDispatch();

    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const updateProfile = async (user: IUser) => dispatch(UpdateUserAsync({ token: Token, user }));

    const [data, setData] = useState<IUser | undefined>(undefined);
    const [error, setError] = useState(undefined);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (Token && !User) {
            setLoading(true);
            dispatch(GetUserAsync({ token: Token }));
        } else if (Token && User) {
            setLoading(false);
            setData(User);
        }

        return () => {
            setData(undefined);
            setError(undefined);
            setLoading(false);
        };
    }, [Token, User, dispatch]);

    return { data, error, loading, updateProfile };
};

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export const useAuthentificate = () => {
    const Token = useAppSelector((state) => state.user.token);
    const Status = useAppSelector((state) => state.user.status);
    const isAuthenticated = useAppSelector((state) => state.user.status === 'auth');

    const dispatch = useAppDispatch();
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const Logout = () => {
        dispatch(logout());
    };

    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const Login = async (email: string, password: string, remember?: boolean) =>
        dispatch(LoginAsync({ email, password, remember }));

    return {
        Token,
        Status,
        isAuthenticated,
        Logout,
        Login,
    };
};

export default userSlice.reducer;
